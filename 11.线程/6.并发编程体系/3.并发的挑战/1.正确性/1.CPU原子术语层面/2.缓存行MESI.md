# 一、背景——多核处理器环境下的缓存行一致协议~~

 在多核处理器中，每个核心通常都**有自己的缓存**。缓存一致性问题是指当**多个处理器同时访问和修改同一个内存地址**时，如何**确保所有处理器都能看到同样的数据**。

## 举例 —— 缓存行怎么导致的不一致？
 处理器 A 从主内存中读取一个变量到它的缓存中。

 处理器 B 也从主内存中读取同一个变量到它的缓存中。
 
 处理器 A 修改了这个变量，并写回到它的缓存中。
 
 处理器 B 继续使用它缓存中的旧值，这样就产生了不一致。


---
# 二、缓存一致性协议—— 为每个缓存行定义了 四种状态
是行业为了解决上述问题的而定协议，有很多实现，用的最多的就是MESI协议，这里讲解这个


## 1.Modified (M)修改 = (独有+修改)
  缓存行包含已修改的数据，这些数据是最新的，并且**与主内存中的数据不一致**。**只有一个缓存**可以持有这个状态。

## 2.Exclusive (E) 独有+未修改
  缓存行包含**未修改**的数据，这些数据与主内存中的数据一致，并且**只有当前处理器(所以是独有)**缓存有这份数据。

## 3.Shared (S) 共享+未修改
  缓存行包含**未修改**的数据，这些数据与主内存中的数据一致，**可以存在于多个缓存中(所以是共享)**。

## 4.Invalid (I)无效
  缓存行无效，不能使用，其他缓存行可能也有，必须**从主内存重新读取数据(所以是无效的)**。



----
# 三、状态转换——读取+写入
以下是CPU发出的指令！

## (一)读取 (Read)=>最终设置为S/E

### 1.Invalid
 如果缓存行处于 **Invalid 状态**，说明无效，则**从主内存读取数据**，并将状态设置为 **Shared 或 Exclusive**(看共享情况而言)。

### 2.Shared 或 Exclusive
 如果缓存行处于 **Shared 或 Exclusive 状态**，则可以**直接读取数据(因为未修改)**。

### 3.Modified
 如果缓存行处于Modified状态，说明该数据**只在本地缓存中**被修改过，**尚未写回内存**，此时**直接从本地缓存中读取数据**，并可能根据需要**将数据写回内存**，同时将**缓存行状态改为 “Shared”**，以**允许其他处理器共享该数据**。(这里改为share很重要！)


----
## (二)写入(write)=>最终一定设置为Modified
### 1.Invalid 或 Shared
 如果缓存行处于 **Shared 或 Invalid 状态**，则需要将**其他缓存中的该缓存行设置为 Invalid**，并将**自己的状态设置为 Modified**。(显然得，因为他这里改了，其他的处理器中的缓存就一定是是过期的，无效的了！就会在主存中再次读取该缓存行数据)，因为当一个处理器尝试写入一个处于 Shared 或 Invalid 状态的缓存行时，必须**确保其他处理器不能再访问该缓存行的旧数据**
 
 ### 2.Exclusive
 如果缓存行处于 Exclusive 状态，则直接将状态**设置为 Modified 并写入数据**。
 

 不能可能是遇到Modified状态，因为该状态就是在这个情况下设置的！

