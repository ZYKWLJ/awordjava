# 一、问题引出
 上面已经讲了**synchronized、ReentrantLock**等锁机制了，但是如果因为**一两个实例字段**的保护而使用同步，是不是会造成巨大的开销？今天这篇文章我们就来详细讲解**进一步降低因同步带来的开销**但**又能达到相同的效果的volatile关键字**。

---
# 二、JMM的局限性

JMM在为每一个线程抽象了一个工作内存，线程间数据操作全在工作内存中，当涉及到共享数据时，**需通过主存来完成消息间的通信**。这就有几个痛点：

### 1.线程间不会立即可见
A线程修改了数据，B和其他线程不能立刻看见

### 2.指令重排序优化
由于提速，指令会重排序已进行优化，这在多线程之间会出现错误

----

# 三一：volatile本质——读写加入内存屏障(指令级别)，免锁开销小

# 三、volatile的作用

## 1.保证线程间的可见性
当一个线程修改了 volatile 变量的值，新值会立即被写回主内存，并且强制其他线程不再从自己的工作线程里面读取，而是从主存中读取，这就能立即看到这个更新值。

#### 如果不使用volatile：

编译器和即时编译器（JIT）为了提升性能，可能会对代码进行优化。例如，将 while (!flag) 循环中的 flag 变量缓存到寄存器或者工作内存中，**之后循环就一直使用这个缓存值，而不再去主内存读取**。只有当**编译器或者 JIT 编译器认为有必要重新读取主内存时**，才会**去更新缓存值**。

## 写屏障SL：写volatile关键字的线程

确保我先写入了这个变量的值，更新好后，你们再来读取！

## 之后是读屏障LS：
在我读这个变量时，**你们就别写了，以免我的出错！**

这里从主存里面读取，就加入了LS屏障，保证我读取的值时，值一定是正确的！


## 2.禁止指令重排序
禁止指令重排序优化。确保 volatile 变量的读写操作按照程序中定义的顺序执行。

共有4种屏障，如下：
![alt text](../../../../../img/指令重排序/4类重排序指令.png)


内存屏障是一种同步机制，**确保特定的内存操作顺序，防止 CPU 和编译器进行指令重排序**。


