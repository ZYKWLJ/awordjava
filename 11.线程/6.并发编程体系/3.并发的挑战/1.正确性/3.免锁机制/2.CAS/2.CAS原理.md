## 一、核心——判断没有其他线程来修改过=>更新前，比较预期值是不是与当前值相同，则说明没有其他线程修改之！

---
## 二、组成
 V：表示内存位置（Variable）
  需要进行比较和交换操作的变量。

 E：表示预期值（Expected value）
  当前线程期望内存位置的值。

 N：表示新值（New value）
  如果**预期值与内存位置的当前值相同**，将**内存位置的值更新为新值**。

----
## 三、原理

 假如线程A从内存中拿到**共享变量i=0**，标记这是**刚从内存中拿到的值为E=0**，这**也是期待值**；后将其在工作内存中加1后，**新值N=1**；**若此过程中，没有其他线程来操作这块内存，内存中的值将是V=0**。线程A现在欲将N写入内存中，覆盖V的之前，会比较之前刚从内存中拿到的值E是否等于现在内存中的值V，如果是，就直接用N覆盖V。这样就实现了确保在这之中，没有其他线程来操作更改过这块内存。这就是大名鼎鼎的CAS。

  如果失败了
   自旋重试
    更新期望值：重新读取共享变量的当前值。

    **重试CAS操作**：再次尝试CAS操作。

 一个确保
  确保本线程拿到共享变量到工作内存中操作过程中，其他线程没有对内存中该变量进行过修改

---
## 四、ABA问题
 问题引出
  CAS也存在一个问题，就是比较交换之时内存的值V确实是和刚拿出来的值（期待的值E）相等，没有变过。但是**有可能是其他线程先进来改成1后**，之后再改为0的，所以只是单纯的比较E与V的值是否相等是不可靠的。

 解决方法——版本号

  AS中增加了版本号的验证功能，**每修改一次i，版本号version＋1**，这样**就算是最后的值相等，版本号不一致也不行**。用和女朋友复合做类比很好。


----
## 五、乐观与悲观锁
### (一) 乐观锁——CAS自旋锁
  CAS 是基于乐观锁的思想：最乐观的估计，**不怕别的线程来修改共享变量**，就算改了也没关系，我吃亏点**再重试**呗
   自旋锁

---
### (二) 悲观锁
  synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。