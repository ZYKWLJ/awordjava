# Monitor监视器——
## 一、所属
 Monitor 本身是 JVM 内部的一套**同步管理机制和数据结构**。

## 二、原理——请求与特定对象或类对象相关联的监视器的所有权。该所有权是一个指针，只能一个线程获取！

### 1.原理——Monitor内部只有一个线程指针！
 当使用 synchronized 给对象上锁时，**对象头中的某些标记位会发生变化**，并且**会通过这些标记与 JVM 内部的 Monitor 机制关联起来**。具体来说就是**该对象头指向了管理同步的Monitor**，而**Monitor内部的Owner结构一次只能存放一个线程**，所以**使得一次只能有一个线程访问该对象**。

  实例方法 this
  静态方法 Class
  代码块形式 lock

 ### 2.一句话总结
  每个对象的对象头都可以设置monoitor的指针，让对象与monitor产生关联，montor的Owner结构一次只能容纳一个线程，即可上锁

## 三、结构
![alt text](../../../../../../img/JVM底层的Monitor结构.png)

### 1.Owner指针
  关联当前获取锁的线程的，只能有一个线程可以获取
### 2.EntryList线性队列=>实现抢所失败，阻塞
  关联没有抢到锁的线程，处于Blocked状态的线程
### 3.WaitSet集合=>实现条件不足，等待
  关联调用了wait方法的线程，处于Waiting状态的线程
 


## 四、流程

 1.代码进入synchorized代码块，先看lock（对象）关联的monitor，**判断Owner是否有线程持有**

 2.如果没有线程持有，**则让当前线程持有，表示该线程获取锁成功**
 
 3.如果有线程持有，则让**当前线程进入entryList进行阻塞(抢锁失败)**，如果Owner持有的线程已经释放了锁，在EntryList中的线程去**竞争锁的持有权（非公平）**
 
 4.如果持锁线程中调用了wait()方法，则会进去**WaitSet中进行等待(一般是条件不足，自行等待!比如转账)**


 ## 细节总结

 所有的锁机制，**都是拥有两个能力**：

 #### 条件不足——自己等待队列，等待唤醒，释放锁
 
 #### 抢锁失败——进入阻塞队列