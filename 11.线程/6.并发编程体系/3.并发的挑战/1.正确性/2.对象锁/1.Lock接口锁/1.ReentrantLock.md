# 一、定义——一个juc包下的可重入对象锁，提供了很灵活、很强大的锁机制

# 二、原理：
被ReentrantLock包围起来的**结构**可以实现确保**任何一个时刻只有一个线程进入临界区**；

# 三、实现步骤：
ReentrantLock 的基本使用步骤是：
**创建 ReentrantLock 实例，调用 lock() 方法加锁，在需要保护的代码块执行完毕后，调用 unlock() 方法释放锁**。
为了确保锁一定会被释放，通常将**unlock() 方法放在 finally 块**中。

# 四、特点：
### 1.可重入锁

### 2.可实现公平锁、非公平锁(传参即可)

### 3.可使用条件对象提供更精细化的锁机制

## 详细讲述这几点：

## (一)条件对象：
### 1.背景：
通常，线程进入临界区后却发现**只有满足了某个条件之后它才能执行**。可以**使用一个条件对象**来管理**那些已经获得了一个锁却不能做有用工作的线程**。(还是银行转账问题！)


### 2.定义
一个锁对象可以有**一个或多个相关联的条件对象**。你可以用**newCondition方法获得一个条件对象**。习惯上会给每个条件对象一个合适的名字来反映它表示的条件。例如，在这里我们建立了一个条件对象来表示“资金充足”条件。




### 4.使用前提：

#### 1.调用前提
 警告:只有当线程**拥有一个条件的锁时**，它才能在这个条件上调用**await(注意是await，多了一个wait!)、signalAll或signal 方法。

#### 2.一定要调用singalAll
 最终需要**有某个其他线程调用signalAll方法**，这一点至关重要。**当一个线程调用await()时，它没有办法重新自行激活**。它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它**就永远不再运行了**。这将导致令人不快的**死锁**(deadlock)现象。如果所有其他线程都被阻塞，最后一个活动线程调用了await方法但没有先解除另外某个线程的阳塞，现在这个线程也会阻塞。此时没有线程可以解除其他线程的阻塞状态，程序会永远挂起。

#### 3.singal()与singalAll
 signal只是**随机选择**等待集中的一个线程，解除这个线程的阻塞状态。
 singalAll是**解除全部**在等待这个条件的所有线程的阻塞状态


# 五、底层原理——AQS
## 1.综述：
ReentrantLock 内部使用了 **AbstractQueuedSynchronizer（AQS）**来实现锁的核心逻辑。
AQS 是一个用于**构建锁和同步器的框架**，它使用一个**整型的 state 变量**来表示锁的状态，以及一个**双向链表**来管理等待获取锁的**线程队列**。

## 2.




---
# 六、细节——对象锁与类锁

## 对象锁与类锁
 注意这里是对象锁，只针对于**多个线程同时访问同一对象**的情况会出现并发安全问题，如果**是不同对象，完全不会发生**
 
## 类级别的锁
  Java中每一个类都对应一个Class对象，如果修饰的是**static类级别的锁话**，无论是通过那一个实例方法来访问包围的代码块，**都将被阻塞**。

```java
// 定义一个静态的 ReentrantLock 实例作为类级别的锁
    private static final ReentrantLock classLock = new ReentrantLock();
```