# 一、背景
javac编译好的字节码文件再磁盘上，而其是需要运行在JVM里面的，并且其运行时需要依赖核心源码，字节码文件和源码文件都是通过类加载子系统加载到JVM管理的内存区域中的！

# 二、作用
1.加载class文件
2.加载核心类库文件(启动类加载器(这样才能跑起来))


# 三、类加载器
不同类加载器里面的类在JVM内部认为是不同的！

# (一)特征
## 1.以加载方式分类：
### 显示加载
 直接在代码中根据`Class.forName(name)`或 `this.getClass().getClassLoadrloadClass()`加载class对象。
### 隐式加载
 通过`JVM自动加载`。比如加载好的类在引用某个类，就又要加载

## 2.以加载器分类：

### 启动类(bootstrap classloader)加载器(C++实现)
### 自定义类加载器


## (二)特性
### 1.双亲委派模型
  如果一个类加载器在收到加载类的请求时，他自己不会去加载这个类，而是把请求`先委托给自己的父类加载器`去完成，依次递归，如果父类可以加载，那就OK，`父类不行的话，就自己去加载`

### 2.可见性
  `子类加载器可以访问父类加载器加载的类型，但是反过来就不行`。
### 3.单一性
  父类加载过的类型，不会再在子类加载其中出现。

## (三)双亲委派模型
定义：子找父
### 优点
  避免类的重复加载，确保类的全局唯一性防止了核心API被篡改(只能有一个String，就是源码里面的！)
### 缺点
  `顶层的类加载器无法访问底层的类加载器`
#### 举例
   比如在系统类中提供了一个接口，该接口需要在应用类中实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而`接口和工厂方法都在启动类加载器中`。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题

----
# 技术面要广——何时打破双亲委派模型？
  Java虚拟机规范
   双亲委派只是**Java虚拟机推荐**的做法，不是一定的比如**“代码热替换”**就是可以打破该模型的。
  双亲委派模型的打破——“代码热替换”

## 1.热替换
热替换是指在程序的运行过程中，**不停止服务,只通过替换程序文件来修改程序的行为。**热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如PHP，只要替换了PHP源文件，这种改动就会立即生效，而**无须重启 Web 服务器**。

    但对 Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是**灵活运用类加载器**。即**两个不同的类加载器加载同一个类** ，在虚拟机内部，**会认为这两个类是完全不同的**。根据这个特点，可以用来模拟热替换的实现。创建自定义的类加载器，在服务不重启的条件下动态替换类文件，这样就可以直接执行新的类文件了。
   

## 2.实现应用的隔离
Tomcat里面部署多个webApp，之间可能类名相同，依赖各异，这时，就需要在他们之间进行隔离，Tomcat 为每个 Web 应用创建独立的类加载器，每个类加载器可以独立加载各自所需的类库，从而实现不同 Web 应用之间的隔离。
   tomcat
   servlet


# 四、类加载全过程详解
**加载、验证、准备、解析、初始化、使用和卸载**七个阶段, 其中, **验证、准备、解析**又被称为解析阶段！

# (一)加载
## 1.通过类全名获取类的二进制流
### 1.1文件系统读入.class文件
### 1.2读入zip、jar归档文件中的数据包
### 1.3网络加载
### 1.4反射

## 2.解析二进制流为`方法区内的数据结构`【Java类模型】
## 3.创建Class对象实例

# Class对象详解：
0.是访问方法区内的类数据的入口

1.是`类存活的唯一评判`

2.是反射基石

特例，数组没有Class方法，无法通过类加载器创建数组类只需要将数组的类型创建好就行了

# (二)链接 
## 1.验证

### 一、格式检查：
(1)class文件是否以**魔数0xCAFEBABE**开头

(2)主版本和副版本号是否在当前JVM的支持范围内

### 二、语义检查
(1)是否所有的类都有父类的存在(Object除外)

(2)是否一些被定义为`final的方法或者类被重写或继承了`

(3)非抽象类是否实现了`所有抽象方法或者接口方法`

### 三、字节码验证

(1)函数的调用是否传递了`正确类型的参数`。

(2)变量的赋值是不是给了`正确的数据类型`等。(原来这些在这里检查的！)

(3)检查栈映射帧的局部变量表和操作数栈是否有着正确的数据类型

### 四、符号引用验证
class文件中的常量池会通过字符串记录将要`使用的其他类或者方法`。
这里就会检查这些常量池中类或者方法`是否真实存在`。


## 2.准备
主要负责为类的`静态变量【sf除外】分配内存`，并将其初始化为`系统默认值0`

## 3.解析
### 作用：
主要负责将类、接口、字段和方法的`符号引用转为直接引用`。即`获取这些属性在内存中的地址`。

### 符号引用·
 符号引用就是一些`字面量的引用`，只是在代码层面的标识数据，是一种逻辑，和`JVM的内部数据结构及内存布局`无关。而直接引用就是这些属性在Java中的`真实地址`。

### 直接引用
 这些属性在Java中的真实地址。


# (三)初始化——显示是初始化类级别的产物！
## 背景：
类的初始化是类装载的最后一个阶段，如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中，然后**JVM才会开始执行Java字节码**。

## 工作：
### 1.执行cinit()方法
工作有为`类级别变量`初始化为程序员定义的值、执行`静态static语句`

# cinlt()方法简介
## 定义
即**类的初始化方法**。该方法仅能由`Java编译器生成并被JVM调用`。

## 组成
clinit()方法是由`类静态成员的赋值语句`以及`static 语句块`合并产生的。

## 双亲委派本质
通常在加载一个类之前，JVM 总是会试图加载该类的父类，因此父类的clinit()方法总是在子类clinit()方法之前被调用(这是本质)

## 谁不会拥有？——Java编译器并不会为所有的类都产生<clinit>()方法
(1)一个类中并没有声明任何的类变量，也没有静态代码块时。

(2)一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来`执行初始化操作`时。

(3)一个类中包含 static final修饰的基本数据类型的字段，这些类字段初始化语句采用`编译时常量表达式`。


# (四)使用
任何一个类在使用之前都必须经历过完整的加载、链接和初始化3个步骤【不一定，因为初始化是有条件的】。一旦一个类成功经历这3个步骤之后，就`等着开发者使用了`。可以在程序中访问和调用它的静态类成员信息(比如静态字段、静态方法等)，或者使用 `new关键字创建对象实例`(这时才是对象阶段~才是蛋糕阶段，之前全是模具的工作~~)。


# (五)卸载
类的生命周期
## 开始
  当类被加载、链接和初始化后，它的生命周期就开始了
## 结束
  本质是Class对象的回收！
  当代表类的`Class对象不再被引用`，即`不可触及时`，`Class对象`就会结束生命周期【前面的GC知识】，类在方法区内的数据也会被卸载