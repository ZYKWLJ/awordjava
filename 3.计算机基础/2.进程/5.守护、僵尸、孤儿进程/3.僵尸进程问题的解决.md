# 如果解决僵尸进程造成的问题： 
![alt text](../../img/如何解决僵尸进程的问题.png)

---
## （1）方案一：wait/waitpid=>不是好办法~

父进程通过 wait 和 waitpid 等函数等待子进程结束，但这会**导致父进程挂起**，所以这并不是一个好办法，**父进程如果不能和子进程并发执行的话，那我们创建子进程的意义就没有**。同时一个 wait 只能解决一个子进程，如果**有多个子进程就要用到多个 wait**

---
## （2）方案二：通过信号机制：=>不会导致父进程阻塞~

子进程退出时，向**父进程发送 SIGCHILD 信号**，父进程**处理 SIGCHILD 信号**，在**信号处理函数中调用 wait 进行处理僵尸进程**。 这样就不会导致父进程挂起阻塞

---
## （3）方案三：fork两次：=>利用祖父进程与孙子进程无关联完成~

原理是**祖父进程与孙子进进程无继承关联关系**，通过 init 进程处理僵尸进程。

具体操作为：

父进程一次 fork() 后产生一个**子进程随后立即执行 wait(NULL) 来等待子进程结束**，然后子进程 fork() 后产生**孙子进程随后**立即exit(0)。这样父进程顺利终止，然后祖父进程继续执行。这时的孙子进程由于失去了它的父进程，将被转交给Init进程托管。于是祖父进程与孙子进程无继承关系了，**它们的父进程均为Init**，Init进程在其子进程结束时会自动收尸，这样也就不会产生僵死进程了 

---

## （4）方案四：kill 父进程：=>充分利用孤儿进程完成资源回收！

严格地来说，僵死进程并不是问题的根源，**罪魁祸首是产生出大量僵死进程的那个父进程**。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大量僵死进程的那个元凶枪毙掉（也就是通过 kill 发送 SIGTERM 或者 SIGKILL 信号啦）。**枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被 init 进程接管**，init 进程会 wait() 这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程就能瞑目而去了。


=>所以说，孤儿进程实际上是对系统优化有好处的，僵尸进程才是有坏处！**孤儿进程的用途之一就是解决僵尸进程的**！