# 一、什么是僵尸进程和孤儿进程：    
     
在 Unix/Linux 系统中，正常情况下，子进程是通过父进程创建的，且**两者的运行是相互独立的**，父进程永远无法预测子进程到底什么时候结束。当一个进程调用 exit 命令结束自己的生命时，**其实它并没有真正的被销毁，内核只是释放了该进程的所有资源，包括打开的文件、占用的内存等**，但是留下一个**称为僵尸进程的数据结构**，这个结构保留了一定的信息（**包括进程号 the process ID，退出状态，运行时间**），这些信息直到父进程通过 **wait()/waitpid()** 来取时才释放。这样设计的目的主要是保证只要父进程想知道子进程结束时的状态信息。那么通过以上分析，有：

---
## •  僵尸进程：
一个进程使用 **fork 创建子进程**，如果子进程退出，而**父进程并没有调用 wait 或 waitpid 获取子进程的状态信息**，那么**子进程的进程描述符仍然保存在系统中**，这种进程称之为僵死进程。  

## •  孤儿进程：
一个**父进程退出**，而**它的一个或多个子进程还在运行**，那么这些子进程将成为孤儿进程。孤儿进程将被 **init 进程(进程号为1)所收养**，并由 init 进程对它们完成状态收集工作。   



---
# 二、僵尸进程与孤儿进程的问题危害：         

## 1.僵尸进程危害——占用进程号

僵尸进程虽然不占有任何内存空间，但如果父进程不调用 wait() / waitpid() 的话，那么保留的信息就不会释放，**其进程号就会一直被占用**，而**系统所能使用的进程号是有限的**，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统**不能产生新的进程**，此即为僵尸进程的危害。         


## 2.孤儿进程危害——无危害，甚至有特殊意义

孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了 init 进程身上，init 进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init，而 **init 进程会循环地 wait() 它的已经退出的子进程**。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会出面处理它的一切善后工作。**因此孤儿进程并不会有什么危害**。