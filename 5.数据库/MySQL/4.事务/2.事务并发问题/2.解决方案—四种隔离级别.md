# 一、4种隔离级别
 ## (一)READ UNCOMMITED  未提交读
###  定义

   这是事务隔离的最低级别。在这种隔离级别下，事务可以读取到其他事务未提交的数据，也就是说，**即使另一个事务还没有完成（没有提交或回滚），当前事务也能看到其修改的数据**。数据库不会对这种读取操作进行任何特殊的锁定或限制，因此读取操作非常快速，但数据的准确性无法得到保证。

 ### 解决

   出现脏读、不可重复读、幻读·


 ## (二)READ COMMITED  已提交读
  ### 定义

   在这个隔离级别下，事务只能读取到其他事务已经提交的数据。这意味着，一个事务在读取数据时，**数据库会确保所读取的数据是已经被其他事务成功提交的**，避免了脏读的问题。**但是其他事物在不同时间点提交的数据可能不一致**。仍然存在不可重复读、幻读问题。

  ### 解决

   解决了脏读，仍然有不可重复读、幻读


 ## (三)REPEATABLE READ  可重复读
  ### 定义
   这是 MySQL 的**默认隔离级别**。在这个级别下，一个事务在整个过程中**多次读取（不同时间点）同一数据时**，会得到相同的结果，即解决了不可重复读问题。数据库通过使用行级锁或其他机制来保证在一个事务中对同一数据的多次读取结果是一致的。
 
 ### 解决
   解决了脏读、不可重复读，**仍然有幻读**


 ## (四)SERIALIZABLE  串行化

 ### 定义
   这是事务隔离的最高级别。在这种隔离级别下，事务会以完全串行的方式执行，即一个事务完全执行完后，另一个事务才会开始执行，就好像事务在一个队列中依次执行一样。数据库通过使用严格的锁机制来保证事务之间不会相互干扰，所有的事务操作都是互斥的，从而保证了数据的绝对一致性和完整性。

 ### 解决
   解决了一切并发安全问题

   这种隔离级别虽然保证了数据的绝对准确性，但会极大地降低数据库的并发性能，因为事务需要排队等待执行，会导致大量的资源等待和锁争用，增加了事务的响应时间和系统的开销。