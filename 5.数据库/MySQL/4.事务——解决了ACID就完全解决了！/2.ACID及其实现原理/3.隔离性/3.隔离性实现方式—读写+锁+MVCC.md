## 一、Isolation 隔离性
  数据库系统提供的隔离机制，保证事务在不受外部并发事务操作的影响，**事务之间不能相互干扰不能相互查看彼此未提交的数据！**

  可以分为**写与写隔离**，**写与读隔离**，分别通过**锁与MVCC**来实现！
![alt text](../../img/事务的隔离性—写写隔离，写读隔离.png)


## 二、引出多事务的三大问题：

### 1.脏读：
A事务在执行过程中，**读取到了B事务还未提交的数据**，称为`脏读`！

### 2.不可重复读：
A事务执行过程中，若对`同一个数据`进行两次读取，在这两次读取之间，B事务修改了这条数据并且进行了完整的提交，那么，这两次读取的数据是不一致的！称为`不可重复读`！

### 3.幻读:
A事务执行过程中，若对`同一个数据集合`进行两次读取，在这两次读取之间，B事务在这个集合里面增加或删除了某一部分数据，导致读到的数量不一致的行数据，称之为`幻读`！



为了解决上面的三个问题，提供了4种隔离级别：
## 三、事务的隔离级别

## 实现方式：
隔离性本质上来说是并发带来的问题，所以可以用锁解决！
但是锁在有些情况下`较为低效`(sql执行中频繁加锁解锁，上下文切换IO损耗严重)，所以mysql是结合锁和`MVCC机制(乐观锁)`来实现的隔离级别！

补充：**上下文本质就是CPU当前服务的资源集合**


### 1.读未提交
![alt text](../../img/隔离级别的4种原理/读未提交.png)

#### 读取数据：——读最新版本
不加锁，直接读取事务版本链中的`最新版本`，也就是当前读，这样就会导致出现脏读、不可重复读、幻读

#### 修改数据：——共享行锁
在修改的数据上加上共享行锁，事务结束时释放，结果是事务修改完毕之前，其他事务不能修改这行数据，但是可以被其他事务读取！



### 2.读已提交
![alt text](../../img/隔离级别的4种原理/读已提交.png)
#### 读取数据：——多个快照读
不加锁，但是使用快照读，即按照mvcc机制读取符合read_view要求的版本数据，**每次查询**都会构造一个read_view，这样就解决了脏读，但是仍未解决不可重复读、幻读

#### 修改数据：——独占行锁
在修改的数据上加上独占行锁，事务结束时释放，结果是事务修改完毕之前，其他事务不能修改也不能读取这行数据



### 3.可重复读
![alt text](../../img/隔离级别的4种原理/可重复读.png)

#### 读取数据：——一个快照读
不加锁，但是使用快照读，即按照mvcc机制读取符合read_view要求的版本数据，但是**无论几次查询**都只是在首次生成一个read_view，这样就解决了脏读、不可重复读，配合next_key行锁可以解决一部分幻读问题！


#### 修改数据：——next_key行锁
在修改的数据上加上next_key行锁，事务结束时释放，结果这个范围内的数据在事务修改完毕之前，其他事务不能修改也不能读取这个**范围内**的数据，这样就能解决不可重复读与幻读问题！

这个next_key锁是针对范围的数据的，包括行与行之间的间隙，既禁止了数据更改，也禁止了数据的插入！



### 4.串行化
![alt text](../../img/隔离级别的4种原理/串行读.png)
#### 读取数据：——共享表锁
加共享表锁，事务结束时释放，同时均读取最新版本！

#### 修改数据：——独占表锁
修改时独占整个表，事务结束时释放，完全串行话执行！



![alt text](../../img/隔离力度与并发力度抉择.png)