# MySQL数据如何与Redis同步？——双写一致性问题——两库同步
## 背景
修改了数据库的数据，也要确保缓存数据一致

## 优：Canal组件
采用的阿里的canal组件实现数据同步：不需要更改业务代码，**部署一个canal服务**。canal服务把自己**伪装成mysql的一个从节点**，当mysql数据更新以后，**canal会读取binlog数据**，然后在通过**canal的客户端获取到数据**，**更新缓存**即可  

## 劣：延时双删
![alt text](/5.数据库/img/延时双删.png)
经典好文=>https://www.dtstack.com/bbs/article/9477

## 本质——让数据库更新完全并且确保消耗掉之前在更新数据库期间其他线程的脏数据读取(即让他们写回缓存)

所以就这样来看：
延迟的目的：
1.确保消耗掉之前在更新数据库期间**其他线程的脏数据读取**(即让他们写回缓存)
2.**集群架构下**，保证**主从有足够时间完成同步**
确保数据库更新在第二次删除之间完成，这样第二次删除之后的线程在访问就是访问的最新的数据
但是不保证第一次删除之后的数据是否正确！

## 流程：
先删除缓存的数据，再次更新数据库，然后线程休眠一段时间，整个系统等待数据库更新完了后，数据库将值回设到redis后，再次删除缓存中可能有的值。

1.首先，代码先删除了 Redis 中的缓存数据，以确保接下来的读取操作会从数据库中**读取最新的数据**。 
2.接着，代码**更新了数据库中的数据**，将数据更新为最新的值。 
3.在此之后，**代码让当前线程休眠一段时间**N，这个时间段是为了给数据库操作足够的时间来完成，确保**数据已经持久化到数据库**中。 
4.最后，代码再次删除 Redis 中的缓存数据。这里是延迟双删的关键步骤。**由于之前已经删除了缓存数据，再次删除的目的是为了防止在 Thread.sleep(N) 的时间内有其他线程读取到旧的缓存数据**。因为在这段时间内，缓存数据已经被清空，所以其他线程在读取数据时会发现缓存中不存在，然后从数据库中读取最新的数据并写入缓存，从而保证了数据的一致性。 需要注意的是，这种延迟双删策略并不能完全保证数据的一致性(主要是在休眠时间内)。

## 伪代码：
```java
#删除缓存
redis.delKey(X)
#更新数据库
db.update(X)
#睡眠
Thread.sleep(N)
#再删除缓存
redis.delKey(X)
```

## 缺点：难以保证延时时间，已弃用！


# 并发安全的条件：
## 1.变量是共享变量
## 2.至少有一个写操作
## 3.没有互斥机制


