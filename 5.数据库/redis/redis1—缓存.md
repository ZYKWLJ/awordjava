# 一、缓存

## 1.缓存穿透
### 定义：
查询一个数据库中不存在的数据(当然中间件中最初也一定不存在)，redis中也不存在，每次查询将发起数据库访问，磁盘IO导致数据库崩溃！
(一般是遭到了攻击)
### 解决
### 本质：
1.我们需要去查DB中存不存在
2.redis中也不存在
针对1，我们可以直接在内存层完成数据是否存在的判断！
针对2，我们可以在数据库中查询后，将确定不存在的数据，返回null值到redis中，以便下次重复访问数据库！
### 方法1——布隆过滤器
本质上是一个二进制数组，通过将数据进行三次hash运算，再次模与数据长度得到三个下标，作为数据的唯一下标，每次查询时，先在内存区中查找(其实每次都会提前把预热数据放在redis中)，不存在就返回，存在就访问。

#### 优缺点：5%误判——哈希碰撞
优点：
1.内存级解决方案，不会造成磁盘访问
2.项目前解决方案，不一致问题发生性很小！
3.针对存在数据的解决方案，攻击时内存友好

缺点：
因为是哈希，所以会有哈希误判，即多个数据映射到同一个下标，实际不存在的数据判断成存在的了，(布隆过滤器经典的一句话：不存在的一定不存在，存在的不一定存在就是来源于此)，那么如何解决？

#### 优化
笔者自己提出的解决方案：使用HashMap类似的解决方案，通过链表、红黑树解决哈希冲突。
具体做法：
## 新增哈希数组
因为哈希id一共有3个，所以最多涉及000-999个哈希位，新建一个数组，将数据是否存在的信息保存在其中，哈希碰撞了就直接用链表或红黑树解决，当然转换因子Factor可以自己设置。
## 是否需要排序
我们的得到的3个hashId需不需要排序？不需要，因为3的特殊性，如下，一个简单的判断就好了，性能应该会很快！
```java
A
AB BA
CAB ABC ACB
```
### 方法2——null隔离
将在数据库中查询不到的数据返回一个null值到Redis，下一次就不会再次重查
### 优缺点：
优点：简单
缺点：
1.内存消耗大

2.一定会导致一次磁盘IO，访问一次数据库，磁盘级别解决方案(**因为只有访问了才知道没有，才会回设**)
3.是运行时解决方案(只是在运行时才回设数据)，可能发生不一致问题
4.针对不存在数据的解决方案，在攻击时，可能内存压力过大！(比之前的布隆过滤器的优化差太多了，因为这是针对不存在数据的，而前面的是存在的数据!如果来了100000个不存在的，前面的还是数据库中的内容，这里就要回设100000个数据!)

### 深层次理解两者差异
null回设是堵，布隆过滤器判断是疏，堵重点是存储外来攻击的数据，疏主要是判断外来攻击的数据。当然真实项目中不能使用堵。

## 2.缓存击穿
### 2.1定义：
热点key在redis中过期时，大量请求发过来，导致DB崩溃。

解决：
## 1.互斥锁
## 本质——回设数据的安全保证
重建缓存数据，并使用redis的setnx命令完成互斥功能，确保我在会设数据过程中不会有线程访问DB，因为其他线程若来，直接在redis那里就休眠了。

## 优缺点
优点：1.高一致性
缺点：1.性能低一点，2.可能死锁

## 2.key的逻辑过期时间设置
## 本质——通过逻辑过期字段确保先用着，不来访问DB
对数据不设置过期时间，而是带一个逻辑过期字段，这就意味着永远也不会导致查不到数据(设置过期时间就会查不到)，访问时，发现逻辑时间过期了，那就先返回之前的数据，自己新开一个线程从DB中加载数据过来!

## 优缺点
优点：1.高性能
缺点：1.一致性低一点
![alt text](img/缓存击穿的2种解决方案.png)


## 3.缓存雪崩
### 定义
大量key同时过期，请求全部来到DB，造成DB崩溃

### 解决
设置不同的过期时间(随机值)，防止大量key同事过期！


# 终极绝招：
限流是保底的，不管是穿透、击穿、雪崩，本质问题就是高并发访问带来的问题，只要是访问，我都可以使用限流来保底！

--------

# MySQL数据如何与Redis同步？
## 本质 双写一致性
采用的阿里的canal组件实现数据同步：不需要更改业务代码，**部署一个canal服务**。canal服务把自己**伪装成mysql的一个从节点**，当mysql数据更新以后，**canal会读取binlog数据**，然后在通过**canal的客户端获取到数据**，**更新缓存**即可  
