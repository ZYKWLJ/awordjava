# 面向对象就一句话：
操作数据，以数据为驱动，凡事以数据中心去想，就好多了！

# JAVA中的类基础知识
### 定义
对象的模版，由**类构建对象的过程**成为创建类的实例
### 格式
```maven
[public|protected|default] [abstract|final|static] class ClassName {}
```
## 顶级类
一个 Java 源文件中**最多只能有一个 public 顶级类**，并且**该类的名称必须与文件名相同**。

### 对顶级类的修饰
```maven
1.public
    一个 Java 源文件中**最多只能有一个 public 顶级类，并且该类的名称必须与文件名相同。
2.无修饰符
    (默认包可见)
3.abstract
    使用 abstract 修饰的顶级类是抽象类，不能被实例化，只能被继承，并且抽象类中可以包含抽象方法。
4.final
    使用 final 修饰的顶级类不能被继承，即不能有子类。
```
## 内部类
显然是在类内部创建的类
### 对顶级类的修饰
```maven
1.public
    内部类可以被任何其他类访问。
2.private
    内部类只能被其外部类访问。
3.protect
    可以被同一个包中的其他类以及不同包中的子类访问。
4.无修饰符
    默认访问修饰符的内部类具有包级访问权限，即只能被同一个包中的其他类访问。
5.final
    使用 final 修饰的内部类不能被继承，即不能有子类。
6.abstract
    使用 abstract 修饰的内部类是抽象类，不能被实例化，只能被继承，并且抽象类中可以包含抽象方法。
    
7.static
    使用 static 修饰的内部类称为静态内部类，它属于外部类本身，而不是外部类的实例。
    静态内部类可以直接访问外部类的`静态成员`，但不能直接访问外部类的`非静态成员`。
```
---
#### 特殊用途
```maven
private 为内部类专属，顶级类不可用
protected 为内部类专属，顶级类不可用
final 为终态类，不可改变与继承
static 为内部类专属，顶级类不可用
```
---
# 对象
# 创建对象的6种方式
## 一、new
构造函数.new关键字【最多的】Date date = new Date()=>使用无参构造器创建了一个对象实例
### 对Date date = new Date()的解析
#### 1.Date
是类元信息，存在方法区中，包含构建一个对象的所有类信息，如类路径、类字段、方法等**
#### 2.new Date()
代表一个Date类型的对象实例
存在于堆中(逃逸成功)
存在于栈上(逃逸失败，直接栈上分配了)
#### 3.date
是一个引用变量，指向堆(栈)中的**对象实例**
该对象实例如果是类字段的定义，作为**类元信息存在于方法区**中； 如果是方法类调用，存在于栈中的**局部变量表**里

### 构造器特点
1.构造器与类同名。
2.每个类可以有一个以上的构造器。
3.构造器可以有0个、1个或多个参数。
4.构造器没有返回值。
5.构造器总是伴随着new操作符一起调用。
6.可以使用var声明局部变量
---

## 二、使用clone()
用于**创建对象副本**的一种机制。是深复制。是 Object 类中的一个方法，**所有 Java 对象都继承了这个方法**。

## 三、使用反序列化
## 四、Class的newInstance()
## 五、Constuctor的newInstance()
## 六、使用第三方库
----

# 对象深浅复制问题
int[] arr={1,2,3}
## 浅复制
int arr1=arr;
本质：只是**创建一个指向同一个堆中的对象的指针**。并没有创建自己的实际存储空间，存储数据。

## 深复制
本质：在堆中**重新开辟出一块空间**，创建新对象，存放相同的数据，引用指向的是这个新对象
### 方式1：
```maven
int[] arr1=new int[arr.length]
for(int i=0;i<arr.length;i++)
{ arr1[i]=arr[1];}
```
### 方式2：
arr1=arr.clone()

## 特殊
static类层面的方法、字段
用static修饰的方法与字段可以直接使用类调用，而无需创建对象

---
# final字段
## 初始化要求
初始化：final 字段必须在定义时或通过构造函数进行初始化。一次初始化后，它的值不能再更改。
### 不可变性
一旦 final 字段被赋值，**其值不能再被更改**。这使得 final 字段在保证数据的一致性和不可变性方面非常有用。
类、对象、字段、方法被final修饰后都不能被继承或重写或修改（指向）
注意final修饰的对象指针不能修改指向，但对象本身可以被修改。

## 线程安全
### 不变性
final 字段在多线程环境下是**线程安全**的，因为其不可变性保证了在不同线程中其值的一致性。
### JMM的保证
JMM 保证当一个对象的构造函数完成时，**final 字段的值已经完全初始化并对其他线程可见**。
这意味着在对象构造完成后， 任何线程读取到这个对象时，final 字段的值总是最新的，不会看到部分初始化的值(相当于自身语言级别的锁)。


# OOP——太极抽风
## 1.多态
### 定义
多态是指在不同情况下，调用同一方法时可以有不同的行为表现。
### 分类
#### 方法重载
(编译时多态),同名不同参，编译器依据参数列表选择具体调用
#### 方法重写
(运行时多态)继承,子类重新定义父类的方法。运行时多态通过父类引用调用子类的重写方法来实现。
**父引用指向子对象**(合理的向上转型)(引用就是在前面这块！)
Animal animal = new Dog();

---
## 2.继承
### 定义
继承机制允许子类中拥有父类中全部方法与字段(final修饰的类或字段或方法除外)。

## 3.抽象
### 定义
抽象是指**隐藏对象的复杂性**，只显示**对象的必要功能**。抽象可以通过**抽象类和接口**来实现。

### 分类
#### 抽象类
1.is-a思想
2.**不能被实例化**
3.可以包含抽象方法和具体方法。
4.可以有实例字段
5.**抽象方法没有方法体，必须由子类实现。子类如没有完全实现，则子类也为抽象类**
6.子类**只能继承一个抽象类**
7.关键字extends表示继承

#### 接口
1.**can-do思想**
2.完全抽象的指示类的行为的机制。
3.只能包含抽象方法与public static final 字段。
4.实现接口的类必须实现接口的所有方法。
5.可以**设置默认方法**。
6.类**可以继承多个接口**。
7.关键字implements表示实现接口


## 4.封装
封装是指将对象的状态（字段）和行为（方法）结合在一起，并隐藏对象的实现细节。
通过封装，类的内部实现对外部不可见，只能通过类提供的公共方法访问和修改对象的状态。
这就是最基础的OOP

