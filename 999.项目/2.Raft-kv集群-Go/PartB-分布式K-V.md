
# 1.单个集群的流程

大致的流程是客户端向后端的 servers 发起请求，后端的服务是由**多个节点**组成的，每个节点之间使用 **raft 进行状态复制**，客户端会选择将**请求发送到 Leader 节点**，然后**由 Leader 节点进行状态复制**，即**发送日志**，当收到**多数的节点成功提交日志的响应之后**，Leader 会**更新自己的 commitIndex**，表示这条日志提交成功，并且 **apply 到状态机**中,进行持久化，然后**返回结果给客户端**。​    ​


# 2.节点故障——BASE理论

kv 服务是由多个 raft 节点组成的，而由于分布式系统中**不可避免的节点故障等缘故**，我们需要去处理这样的 failure 问题，这样才能够保证我们的分布式系统是**始终可用、可靠**的，即在**大多数节点正常下依然能够正常响应请求，容忍少数节点发生各种未知错误**。


## 解决方案：客户端重复请求
如果我们的客户端向集群中的 Leader 发送了一个请求，Leader 接收到请求之后，因为某种原因出现了故障，并且**降级为 Follower**，这时候**客户端便一直等不到回复**。直到客户端请求超时，那么它就会**向下一个节点重试请求**，一直轮询，直到**正确得到了 Leader 的回应**。


# 3.重复请求——保证线性一致性——防止数据覆盖！

## 场景描述：
试想这样一个场景：
分布式 KV 有一个客户端，先执行了 Put(x, 1) 请求，将 x 的值设置为 1，接着又执行了 Put(x，2)，将 x 的值设置为了 2。
如果 Put(x, 1) 在执行的过程中，**对应的节点发生了故障**，那么**它会重试请求**，又将 x 的设置为了 1，那么这便**违背了线性一致性**。​即发生了数据的覆盖！


## 解决方案：
线性一致性要求每个客户端的请求****应该立即被执行**，并且**只被执行一次**，对于重试的请求，我们应该如何避免其被执行多次呢？

## map存储唯一命令
给客户端的每个命令赋予一个唯一的标识，当命令执行完之后，将命令标识和执行的结果保存到状态机中的一个 map 里面。每次请求的时候，我们首先从这个 map 中根据唯一标识获取是否存在这个命令，如果存在的话，则说明已经执行过了，则直接返回保存的结果，而不用再发送到 raft 模块进行同步。