## 一、.RabbitMQ消息的重复消费问题如何解决的？——保证消息幂等的
### 1.唯一标识法则
 我们当时消费者是设置了**自动确认机制**，当服务**还没来得及给MQ确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息。这样就重复消费了** 因为我们当时处理的支付（订单|业务唯一标识），**它有一个业务的唯一标识，我们再处理消息时，先到数据库查询一下，这个数据是否存在**，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了

### 2.分布式锁
 其实这个就是典型的幂等的问题，比如，**redis分布式锁、数据库的锁**都是可以的。

---
## 二、Rabbitmq死信交换机？延迟队列？
### 1.延迟队列实现方式
#### 1.1延迟队列=死信交换机+TTL
##### ①死信
   消息超时未消费
##### ②死信交换机
   Rabbitmq专门为死信准备的交换机，绑定延迟队列。
##### ③具体实施
   在我们发消息的时候可以**按照需求指定TTL的时间**，然后**故意不消费他，超时后，就会自动进入延时队列**

#### 1.2. 延迟队列插件
  在RabbitMQ中安装一个死信插件，这样更方便一些，我们只需要在声明交互机的时候，**指定这个就是死信交换机**，然后在发送消息的时候**直接指定超时时间**就行了(超时了就到这里面来!)，相对于**死信交换机+TTL**要省略了一些步骤。

### 2.典型运用：
买票超时系统！支付超时系统，超过时间自动取消！

---
## 三、如果有100万消息堆积在MQ , 如何解决?

### (一)提高消费能力

#### 1.多线程消费任务
 
#### 2.增加更多消费者
  使用工作队列模式, 设置多个消费者消费消费同一个队列中的消息

### (二)扩大队列容积，提高堆积上限
 可以使用RabbitMQ**惰性队列**

  ①接收到消息后直接存入磁盘而非内存

  ②消费者要消费消息时才会从磁盘中读取并加载到内存

  ③支持数百万条的消息存储


## 四、RabbitMQ的高可用机制？

### (一)镜像集群结构
#### 一主多从
#### 故障恢复

 镜像队列结构是一主多从，所有操作都是主节点完成，然后同步给镜像节点，如果主节点宕机后，
镜像节点会替代成新的主节点，不过在主从同步完成前，主节点就已经宕机，可能出现数据丢失。
 
### (二)仲裁队列
 #### 主从模式(基于Raft模式确保强一致)