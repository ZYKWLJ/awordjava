# 一、背景引出

当mq投递消息给消费者后，需要知道**消费者的处理状态**如何。因为**消息投递给消费者了，不一定代表就被正确消费了**。

---

## 二、可能的问题
 ### 1. 投递过程中出现网络状况
 ### 2. 消费者接受消息后突然宕机
 ### 3. 消费者消息处理不当·

---
# 三、解决

# (一)mq要知道消费者的处理状态——提供了消费者的确认机制
### 一、消费者回执信息
  当消费者处理消息后，应该发送给mq一个**回执**。告知mq自己的**消费状态**
   
### ack
    成功处理了消息
    mq可以大胆的从队列删除消息了
### nack
    消息处理失败

    mq需要再次投递消息
### reject
    消息拒绝处理
    
    消息本身有问题，mq删除之。
  
  ---
### 细节—— SpringAMQP内置的消息确认的工作
![alt text](../../../../img/SpringAMQP的消息消费自动确认功能(auto).png)

   直接使用auto 模式。

    利用AOP给我们的消息处理做了**环绕通知**，只有在消息成功消费之后，消息才会被删除，其他的情况消息还在队列中保留着呢。

    而且根据业务异常的不同，返回不同值

     业务异常
      返回nack
     
     消息处理校验异常
      返回reject


# (二)消费者的本地失败重试机制
 ## 问题：
  默认消费者的在消息处理失败后，消息会**不断requeue到队列**，再**重新发送给消费者**。如果消费者一直出错，就会一直重试，**无限循环，导致mq的消息处理飙升。带来不必要的压力**

---
 ## 解决：

### 消费者的本地失败重试机制——在消费者端进行重试，不会在与队列进行RPC，极大减轻了网络开销与mq的承载能力！
   异常时利用消费者端的本地失败重试，而非无限制的requeue

   **设置好本地重试次数**，如果超过仍未消费成功，Spring的处理如下——
   本地重试**在消费者内部进行**，不会将消息重新放回队列，避免了**消息在队列和消费者之间频繁传输**所带来的**网络开销**和**队列资源占用**。它主要利用消费者自身的计算资源进行重试，减少了对消息队列服务器的压力。

    默认：
    
    返回reject，mq中消息就直接丢弃
    
    返回nack，消息requeue
    
    将消息投递至指定**交换机**

     **专门存放异常消息的队列**，后续由人工集中处理